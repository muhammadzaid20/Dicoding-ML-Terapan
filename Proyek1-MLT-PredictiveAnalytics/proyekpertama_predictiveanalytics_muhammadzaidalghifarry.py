# -*- coding: utf-8 -*-
"""ProyekPertama_PredictiveAnalytics_MuhammadZaidAlghifarry.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tHy13tO4kjjOaX8m7-Cj70zakDn9J9Wx

#<font color="#00CED1" size="6">**Proyek Pertama: Membuat Model Predictive Analytics**</font>

## <font color="#D0BFFF"><h3>Domain Proyek</font>

> **Latar belakang**
  * Berdasarkan [data](https://media.neliti.com/media/publications/48920-ID-statistik-transportasi-2013.pdf) dari Badan Pusat Statistik tahun 2015, jumlah keberangkatan penumpang dan barang di bandara Indonesia pada tahun 1999-2013 , jumlah keberangkatan penumpang dan kargo di bandara Indonesia mengalami peningkatan yang signifikan. bermakna bahwa minat masyarakat Indonesia akan travelling atau melancong meningkat. [(Septiadi, 2016)](https://openlibrarypublications.telkomuniversity.ac.id/index.php/management/article/view/2941)
  * Seiring peningkatan minat masyarakat akan travelling, timbul banyak keluhan terkait harga tiket yang mahal, atau harga tiket yang tidak sesuai dengan faktor-faktor penerbangan (maskapai, durasi tempuh, dll).

> **Mengapa masalah tersebut harus diselesaikan.**
  * karena harga tiket pesawat yang tidak sesuai dengan faktor-faktor penerbangan dapat menjadi hambatan bagi masyarakat dalam merencanakan perjalanan.
    * mengakibatkan ketidakpuasan pelanggan, meningkatkan biaya perjalanan, dan mengurangi daya saing industri penerbangan.

> **Bagaimana masalah tersebut harus diselesaikan.**
  * dengan memastikan kesesuaian harga tiket dengan faktor-faktor penerbangan yang relevan, sehingga memberikan pengalaman perjalanan yang lebih baik bagi konsumen dan menjaga keberlanjutan industri penerbangan.
  * Salah satu nya dengan menerapkan teknik predictive modelling untuk memprediksi harga tiket pesawat berdasarkan faktor-faktor yang memengaruhinya,
    * sehingga harga yang ditawarkan dapat lebih transparan, adil, dan sesuai dengan nilai yang diberikan kepada konsumen.

## <font color="#D0BFFF"><h3>Business Understanding</font>

>**Kasus: Prediksi Harga Tiket Pesawat**
  * Keinginan:
    * ingin membuat model machine learning untuk memprediksi harga tiket pesawat dengan teknik predictive modelling.
  * Tujuan:
    * untuk mendapatkan tiket pesawat termurah di bawah harga rata-rata.
    * untuk mengetahui harga terpantas untuk tiket pesawat dengan faktor-faktor tertentu.

>**Problem Statements, Goals, Solution Statements**
* Problem Statements
  * Dari serangkaian fitur yang ada, fitur apa yang paling berpengaruh terhadap harga tiket pesawat?
  * Bagaimana cara membangun model machine learning untuk memprediksi harga tiket pesawat dengan akurasi tertinggi?
* Goals
  * Mengetahui fitur yang paling berkorelasi dengan harga tiket pesawat.
  * Membuat model machine learning yang dapat memprediksi harga tiket pesawat seakurat mungkin.
* Solution Statements
  * Melakukan analisis korelasi untuk mengidentifikasi fitur-fitur yang memiliki hubungan yang kuat dengan harga tiket pesawat.
  * Menerapkan algoritma K-Nearest Neighbor, Random Forest, dan Boosting Algorithm untuk membangun model prediksi yang akurat.
    * Melakukan Hyper parameter tuning terhadap model tersebut
    * Menggunakan metrik evaluasi Mean Squared Error (MSE), Train Score, dan Test Score untuk mengukur kualitas prediksi dari model yang dikembangkan.
    * Memilih model yang memiliki nilai kesalahan prediksi terendah dan skor test prediksi terbaik sebagai solusi utama untuk memprediksi harga tiket pesawat.

>**Metodologi**
  * Prediksi harga tiket pesawat adalah tujuan yang ingin dicapai.
  * harga merupakan variabel kontinu.
  * menggunakan penyelesaian secara regresi, karena untuk memprediksi variabel kontinu
  * membangun model regresi dengan harga tiket pesawat sebagai target.

>**Metrik**
  * kasus regresi, metrik yang digunakan, Mean Squared Error (MSE), train score, dan test score.
  * Pengembangan model menggunakan beberapa algoritma ML, K-Nearest Neighbor, Random Forest, dan Boosting Algorithm.
    * Dari ketiga model ini, akan dipilih satu model yang memiliki nilai kesalahan prediksi terkecil dan tes score terbaik.

## <font color="#D0BFFF"><h3>Data Understanding</font>

#### **Penjelasan**

1. Deskripsi Dataset
  * berisi informasi tentang penerbangan, seperti maskapai penerbangan, tanggal keberangkatan, bandara keberangkatan dan kedatangan, rute penerbangan, waktu keberangkatan dan kedatangan, durasi penerbangan, jumlah transit, informasi tambahan, dan harga tiket.
2. Data Loading
  * Proses mengimpor atau memuat dataset ke dalam lingkungan analisis data
3. EDA - Variable Description
  * penjelasan terhadap variabel-variabel dalam dataset, jenis variabel, dan tipe data setiap variabel.
4. EDA - Dataset Format Convertion
  * mengubah format tanggal, waktu, dan hari.
5. EDA - Missing Value and Outliers Handling
  * dilakukan penanganan terhadap nilai yang hilang (missing values) dan data ekstrem (outliers) dalam dataset.
  * mengisi atau menghapus nilai yang hilang,
  * menangani data ekstrem.
6. EDA - Univariate Analysis
  * melakukan analisa dari setiap fitur satu per satu.
  * mencakup statistik deskriptif, distribusi frekuensi, dan visualisasi untuk masing-masing variabel dalam dataset.
7. EDA - Multyvariate Analysis
  * melakukan analisa tentang pengaruh atau hubungan antara dua atau lebih variabel dalam dataset.
  * melibatkan teknik korelasi matriks, dan perbandingan pola atau tren pada plot
  * untuk memahami pola dan tren yang terjadi antara variabel.

### **Deskripsi Dataset**

* Data yang digunakan, Diamond dataset dari repository [Flight Price Prediction](https://www.kaggle.com/datasets/muhammadbinimran/flight-price-prediction/)

* Dataset memiliki 10683  catatan penerbangan dengan berbagai karakteristik dan harga tiket.
* Kolom Price merupakan label atau target prediksi.

* Keterangan fitur:
  - Airline: Nama maskapai penerbangan yang mengoperasikan penerbangan.
  - Date_of_Journey: Tanggal keberangkatan penerbangan.
  - Source: Lokasi keberangkatan penerbangan.
  - Destination: Lokasi tujuan penerbangan.
  - Route: Rute penerbangan dari lokasi keberangkatan ke lokasi tujuan.
  - Dep_Time: Waktu keberangkatan penerbangan.
  - Arrival_Time: Waktu kedatangan penerbangan.
  - Duration: Durasi total penerbangan dari keberangkatan hingga kedatangan.
  - Total_Stops: Jumlah pemberhentian yang dilakukan oleh penerbangan.
  - Additional_Info: Informasi tambahan mengenai penerbangan.
  - Price: Harga tiket pesawat.

### **Data Loading**
"""

# Commented out IPython magic to ensure Python compatibility.
#@markdown Import library

import pandas as pd
from IPython.display import clear_output
# %matplotlib inline
import matplotlib.pyplot as plt
from wordcloud import WordCloud
from sklearn.feature_extraction.text import CountVectorizer, TfidfTransformer, TfidfVectorizer
from sklearn import svm
from sklearn.metrics import classification_report
# %pip install opendatasets
import opendatasets as od
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline
import seaborn as sns

clear_output()

#@markdown Download dataset

import zipfile
import os

os.environ['KAGGLE_USERNAME'] = "fgfgfg333334"
os.environ['KAGGLE_KEY'] = "24e3a9b450813d932f22ea7b46c4653e"

!kaggle datasets download -d muhammadbinimran/flight-price-prediction

zip_file_path = "/content/flight-price-prediction.zip"
extract_folder_path = "/content/flight-price-prediction"

with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
    zip_ref.extractall(extract_folder_path)

#@markdown Load dataset
data_train = None
data_train = pd.read_csv('/content/flight-price-prediction/Data_Train.csv')

data_train.head()

"""### **EDA - Variabel Description**"""

#@markdown Mengecek informasi dataset

data_train.info()

"""> Diperoleh informasi:
  * Dataset memiliki 10683 baris dan 11 kolom.
  * Terdapat 10 kolom bertipe objek (string) dan 1 kolom bertipe int64.
  * Beberapa kolom memiliki nilai null,
    * yaitu kolom Route dan Total_Stops.
  * Kolom Price adalah kolom numerik yang memiliki tipe data int64, sedangkan kolom lainnya adalah kolom kategorikal (objek).

### **EDA - Dataset Format Convertion**
"""

#@markdown Konversi Format

# Konversi kolom Dep_Time
data_train["Dep_Hour"] = pd.to_datetime(data_train.Dep_Time).dt.hour
data_train["Dep_Min"] = pd.to_datetime(data_train.Dep_Time).dt.minute
data_train.drop(["Dep_Time"], axis = 1, inplace = True)

# Konversi kolom Date_of_Journey
data_train["Departure_Day"] = pd.to_datetime(data_train.Date_of_Journey, format="%d/%m/%Y").dt.day
data_train["Departure_Month"] = pd.to_datetime(data_train.Date_of_Journey, format="%d/%m/%Y").dt.month
data_train.drop(["Date_of_Journey"], axis = 1, inplace = True)

# Konversi kolom 	Arrival_Time
data_train["Arrival_Hour"] = pd.to_datetime(data_train.Arrival_Time).dt.hour
data_train["Arrival_Min"] = pd.to_datetime(data_train.Arrival_Time).dt.minute
data_train.drop(["Arrival_Time"], axis = 1, inplace = True)

# Konversi kolom Duration dalam menit
duration_hours = []
duration_mins = []

for dur in data_train["Duration"]:
    if 'h' in dur and 'm' in dur:
         # membagi string dur menjadi dua bagian berdasarkan spasi, dan menyimpan hasilnya ke dalam variabel hours dan mins
        hours, mins = dur.split()
        duration_hours.append(int(hours.split('h')[0]))
        duration_mins.append(int(mins.split('m')[0]))
    elif 'h' in dur:
        duration_hours.append(int(dur.split('h')[0]))
        duration_mins.append(0)
    elif 'm' in dur:
        duration_hours.append(0)
        duration_mins.append(int(dur.split('m')[0]))
    else:
        duration_hours.append(0)
        duration_mins.append(0)

data_train["Duration_Hours"] = duration_hours
data_train["Duration_Mins"] = duration_mins
data_train.drop(["Duration"], axis = 1, inplace = True)

data_train['Duration_Time'] = (data_train['Duration_Hours'] * 60 + data_train['Duration_Mins'])
data_train.drop(columns=['Duration_Hours', 'Duration_Mins'], inplace=True)

data_train.head()

"""### **EDA - Missing Value and Outliers Handling**

#### **Missing Value Handling**
"""

#@markdown Cek missing value

# Filter kolom dengan nilai NaN
nan_values = data_train.isnull().sum()
nan_columns = nan_values[nan_values != 0]

# Menghitung total jumlah baris yang memiliki nilai null atau NaN
null_counts = data_train.isnull().sum()
total_miss_rows = data_train.isnull().any(axis=1).sum()

print("Jumlah baris missing value: ", total_miss_rows)

print("Kolom dengan missing value:")
print(nan_columns)

"""> Hasil analisa Missing value:
  * terdapat nilai null pada kolom Duration dan hours
  * terdapat nilai nan pada kolom Duration dan hours

> Hasil keputusan dari Missing value:
  * Karena missing value hanya terdapat pada satu sampel, yang mana tidak akan menghilangkan informasi, maka keputusannya adalah:
    * menghapus baris yang memiliki missing value
"""

#@markdown Menghapus missing value

data_train.dropna(inplace = True)

# Filter kolom dengan nilai NaN
nan_values = data_train.isnull().sum()
nan_columns = nan_values[nan_values != 0]

# Menghitung total jumlah baris yang memiliki nilai null atau NaN
null_counts = data_train.isnull().sum()
total_miss_rows = data_train.isnull().any(axis=1).sum()

print("Jumlah baris missing value: ", total_miss_rows)

print("Kolom dengan missing value:")
print(nan_columns)

"""#### **Outliers Handling**"""

#@markdown Visualisasi semua fitur numerik

import matplotlib.pyplot as plt
import seaborn as sns

# Pilih kolom-kolom dengan tipe data integer dan float
numeric_columns = data_train.select_dtypes(include=['int64', 'float64']).columns

# Hitung jumlah subplot yang dibutuhkan
num_plots = len(numeric_columns)

# Tentukan ukuran grid subplot
num_cols = 3
num_rows = (num_plots + num_cols - 1) // num_cols

# Buat subplot
fig, axes = plt.subplots(num_rows, num_cols, figsize=(15, 10))

# Loop melalui setiap kolom numerik dan plot dalam subplot
for i, column in enumerate(numeric_columns):
    row = i // num_cols
    col = i % num_cols
    ax = axes[row, col]
    sns.boxplot(data=data_train[column], orient="h", ax=ax, legend=False)
    ax.set_title(f'Boxplot of {column}')
    ax.set_xlabel('Nilai')
    ax.set_ylabel('Kolom')

# Hapus subplot yang tidak digunakan
for i in range(num_plots, num_rows * num_cols):
    fig.delaxes(axes.flatten()[i])

plt.tight_layout()
plt.show()

#@markdown Membuat batas bawah dan batas atas

Q1 = data_train.quantile(0.25)
Q3 = data_train.quantile(0.75)
IQR=Q3-Q1
data_train=data_train[~((data_train<(Q1-1.5*IQR))|(data_train>(Q3+1.5*IQR))).any(axis=1)]

#@markdown Visualisasi semua fitur numerik setelah drop out outliers

import matplotlib.pyplot as plt
import seaborn as sns

numeric_columns = data_train.select_dtypes(include=['int64', 'float64']).columns

# Hitung jumlah subplot yang dibutuhkan
num_plots = len(numeric_columns)

# Tentukan ukuran grid subplot
num_cols = 3
num_rows = (num_plots + num_cols - 1) // num_cols

# Buat subplot
fig, axes = plt.subplots(num_rows, num_cols, figsize=(15, 10))

# Loop melalui setiap kolom numerik dan plot dalam subplot
for i, column in enumerate(numeric_columns):
    row = i // num_cols
    col = i % num_cols
    ax = axes[row, col]
    sns.boxplot(data=data_train[column], orient="h", ax=ax, legend=False)
    ax.set_title(f'Boxplot of {column}')
    ax.set_xlabel('Nilai')
    ax.set_ylabel('Kolom')

# Hapus subplot yang tidak digunakan
for i in range(num_plots, num_rows * num_cols):
    fig.delaxes(axes.flatten()[i])

plt.tight_layout()
plt.show()

"""### **EDA - Univariate Analysis**"""

#@markdown  Bagi fitur pada dataset menjadi dua bagian

categorical_features = ['Airline', 'Source', 'Destination', 'Route', 'Additional_Info', 'Total_Stops']
numerical_features = ['Price', 'Dep_Hour', 'Dep_Min', 'Departure_Day', 'Departure_Month', 'Arrival_Hour', 'Arrival_Min', 'Duration_Time']

"""#### **Categorical features**

##### **Plot**
"""

#@markdown Visualisasi fitur kategorik: Airline

print(categorical_features[0])
feature = categorical_features[0]
count = data_train[feature].value_counts()
percent = 100*data_train[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature);

#@markdown Visualisasi fitur kategorik: Source

print(categorical_features[1])
feature = categorical_features[1]
count = data_train[feature].value_counts()
percent = 100*data_train[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature);

#@markdown Visualisasi fitur kategorik: Destination

print(categorical_features[2])
feature = categorical_features[2]
count = data_train[feature].value_counts()
percent = 100*data_train[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature);

#@markdown Visualisasi fitur kategorik: Route

print(categorical_features[3])
feature = categorical_features[3]
count = data_train[feature].value_counts()
percent = 100*data_train[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature);

#@markdown Visualisasi fitur kategorik: Additional_Info

print(categorical_features[4])
feature = categorical_features[4]
count = data_train[feature].value_counts()
percent = 100*data_train[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature);

#@markdown Visualisasi fitur kategorik: Total_Stops

print(categorical_features[5])
feature = categorical_features[5]
count = data_train[feature].value_counts()
percent = 100*data_train[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature);

"""##### **Hasil analisa**

> Hasil analisis distribusi:
  * Airline:
    * Mayoritas penerbangan berasal dari maskapai Jet Airways, IndiGo, dan Air India.
    * beberapa maskapai hanya menyumbang sebagian kecil dari sampel.
  * Source dan Destination:
    * Delhi adalah sumber terbanyak dan Cochin adalah tujuan terbanyak.
  * Route:
    * memiliki variasi yang sangat tinggi dengan banyak kombinasi rute yang berbeda.
    * Informasi tentang rute dan jumlah berhenti (Total_Stops) sudah tersedia dalam kolom lain.
    * informasi tambahan yang diberikan oleh kolom "Route" tidak memberikan kontribusi yang signifikan terhadap prediksi harga tiket.
  * Additional_Info:
    * memiliki distribusi data yang tidak seimbang, sebagian besar data adalah "No info" hampir 80%.
    * Terdapat ketimpangan dengan sampel yang lain.
  * Total_Stops:
    * mayoritas penerbangan memiliki 1 stop atau non-stop,
    * Penerbangan 2 stops cukup umum,
    * penerbangan dengan 3 atau 4 stops sangat jarang terjadi. masing-masing menyumbang sekitar 0.3% dan 0.0% dari total sampel.

> sehingga dapat kita simpulkan:
  * kolom Route,
    * terdapat banyak sekali variasi data (128 variasi data), menyebabkan,
      * meningkatkan resiko overfitting,
        * odel menjadi terlalu spesifik terhadap data pelatihan, sehingga mengurangi kemampuan untuk melakukan generalisasi dengan baik pada data baru.
      * membutuhkan model yang lebih kompleks,
        * pada projek ini model yang digunakan tidak cukup kompleks
      * kinerja model,
        * variasi data yang cukup banyak, dapat meningkatkan kemunculan noise pada pelatihan model
    * Informasi tentang rute sudah tersedia dalam kolom Total_Stops .
      * informasi tambahan yang diberikan oleh kolom "Route" tidak memberikan kontribusi yang signifikan terhadap prediksi harga tiket.
    * Keputusan : KOLOM INI PERLU DI HAPUS.
  * kolom Additional Info,
    * memiliki distribusi data yang tidak seimbang, sebagian besar data adalah "No info" hampir 80%, menyebabkan,
      * model cenderung lebih memperhatikan kategori mayoritas daripada kategori-kategori minoritas dan mayoritas data terkonsentrasi pada satu kategori. sehingga mengurangi kemampuan model untuk memprediksi kategori-kategori minoritas dengan baik.
      * model terlalu sensitif terhadap pola yang muncul dalam data pelatihan tetapi tidak umum.
      * kemungkinan model mengabaikan kategori minoritas.
    * Keputusan : KOLOM INI PERLU DI HAPUS.
"""

#@markdown Keputusan

data_train.drop(['Route', 'Additional_Info'], axis=1, inplace=True)

categorical_features = ['Airline', 'Source', 'Destination', 'Total_Stops']

"""#### **Numerical features**

##### **Plot**
"""

#@markdown Melihat distribusi data numerik

data_train.hist(bins=50, figsize=(20,15))
plt.show()

#@markdown Melihat deskripsi data numerik

description = data_train.describe()
print(description)

"""##### **Hasil analisa**

> informasi fitur-fitur numerik:
  * Price:
    * Rata-rata harga tiket, 8874.55,
    * standar deviasi sekitar 4064.67.
    * menunjukkan variasi yang cukup besar dalam harga tiket.
    * Harga tiket berkisar dari 1759 hingga 23001.
  * Departure Time (Jam Keberangkatan):
    * Rata-rata jam keberangkatan, 12:53 siang.
    * Jam keberangkatan dari pukul 00:00 hingga 23:00.
  * Departure Minute (Menit Keberangkatan):
    * Rata-rata menit keberangkatan, menit ke-24.
    * Menit keberangkatan berkisar dari 0 hingga 55.
  * Departure Day (Hari Keberangkatan):
    * Rata-rata hari keberangkatan, tanggal ke-14.
    * Hari keberangkatan, dari tanggal 1 hingga 27.
  * Departure Month (Bulan Keberangkatan):
    * Rata-rata bulan keberangkatan, bulan ke-5.
    * Bulan keberangkatan, dari bulan ke-3 hingga ke-6.
  * Arrival Hour (Jam Kedatangan):
    * Rata-rata jam kedatangan, pukul 13:32 siang.
    * Jam kedatangan, dari pukul 00:00 hingga 23:00.
  * Arrival Minute (Menit Kedatangan):
    * Rata-rata menit kedatangan, menit ke-25.
    * Menit kedatangan, dari 0 hingga 55.
  * Duration Time (Durasi dalam menit):
    * Rata-rata durasi perjalanan, 10 jam 43 menit.
    * Standar deviasi yang tinggi menunjukkan variasi yang signifikan dalam durasi perjalanan.
    * Durasi perjalanan berkisar antara 5 menit hingga 47 jam 40 menit.

### **EDA - Multivariate Analysis**

#### **Categorical features**

##### **Plot**
"""

#@markdown Plot: Melihat pengaruh fitur berjenis Categorical terhadap label "price"

import matplotlib.pyplot as plt
import seaborn as sns

#categorical_features = ['Airline', 'Source', 'Destination', 'Total_Stops']

# Mengatur jumlah kolom dan baris untuk subplot
num_cols = 2
num_rows = (len(categorical_features) + num_cols - 1) // num_cols

# Membuat subplot
fig, axes = plt.subplots(num_rows, num_cols, figsize=(16, 10))

# Iterasi melalui fitur kategorikal
for i, feature in enumerate(categorical_features):
    row = i // num_cols
    col = i % num_cols

    # Plot bar untuk fitur tertentu
    sns.barplot(x=feature, y='Price', data=data_train, ax=axes[row][col])
    axes[row][col].set_title('Average Price vs {}'.format(feature))
    axes[row][col].tick_params(axis='x', rotation=45)

# Hapus subplot yang tidak terpakai
if len(categorical_features) % num_cols != 0:
    for i in range(len(categorical_features), num_rows * num_cols):
        fig.delaxes(axes.flatten()[i])

plt.tight_layout()
plt.show()

#@markdown Deskripsi: Melihat pengaruh fitur berjenis Categorical terhadap label "price"

for feature in categorical_features:
    avg_price_by_category = data_train.groupby(feature)['Price'].mean().reset_index()
    print("Average Price vs", feature)
    print(avg_price_by_category)
    print()

#@markdown ANOVA: Melihat pengaruh fitur berjenis Categorical terhadap label "price"

import scipy.stats as stats

print("ANOVA (Analysis of Variance) :\n")

for feature in categorical_features:
    group_values = []
    for category in data_train[feature].unique():
        group_values.append(data_train[data_train[feature] == category]['Price'])

    # Perform ANOVA test
    f_val, p_val = stats.f_oneway(*group_values)

    print("Anova Result for {} vs Price:".format(feature))
    print("F-statistic:", f_val)
    print("p-value:", p_val)
    print()

"""##### **Hasil analisa**

> Dapat disimpulkan dari analisa plot:
  1. Average Price vs Airline:
    * Harga tiket rata-rata tertinggi,
      * Jet Airways Premium economy,
      * diikuti oleh maskapai Multiple carriers dan Jet Airways.
    * Maskapai dengan harga tiket paling rendah,
      * Trujet,
      * diikuti oleh SpiceJet dan Air Asia.
  2. Average Price vs Source:
    * Rata-rata harga tiket penerbangan tertinggi
      * penerbangan yang berangkat dari Delhi, diikuti oleh Kolkata.
    * Rata-rata harga tiket penerbangan paling rendah
      * Penerbangan yang berangkat dari Mumbai
  3. Average Price vs Destination:
    * Rata-rata harga tiket penerbangan tertinggi
      * penerbangan menuju Cochin dan New Delhi.
    * Destinasi harga tiket paling rendah
      * Kolkata dan Chennai.
  4. Average Price vs Total_Stops:
    * Rata-rata harga tiket meningkat dengan peningkatan jumlah transit.
    * Penerbangan non-stop memiliki rata-rata harga tiket yang lebih rendah dibandingkan dengan penerbangan dengan jumlah transit lebih dari satu.

> Dapat disimpulkan dari analisa ANOVA:
  1. Airline vs Price:
    * F-statistic: 734.98
      * F-statistic yang tinggi menunjukkan perbedaan signifikan antara rata-rata harga tiket pada setiap level Total_Stops
    * p-value: 0.0
      * Nilai p-value yang rendah, menunjukan perbedaan yang signifikan bukanlah suatu kebetulan.
    * ada pengaruh yang signifikan dari jenis pesawat terhadap harga tiket.
  2. Source vs Price:
    * F-statistic: 650.04
      * F-statistic yang tinggi menunjukkan perbedaan signifikan antara rata-rata harga tiket pada setiap kota keberangkatan.
    * p-value: 0.0
      * Nilai p-value yang rendah, menunjukan perbedaan yang signifikan bukanlah suatu kebetulan.
    * ada pengaruh yang signifikan dari kota keberangkatan terhadap harga tiket.
  3. Destination vs Price:
    * F-statistic: 801.26
      * F-statistic yang tinggi menunjukkan perbedaan signifikan antara rata-rata harga tiket pada setiap kota tujuan.
    * p-value: 0.0
      * Nilai p-value yang rendah, menunjukan perbedaan yang signifikan bukanlah suatu kebetulan.
    * ada pengaruh yang signifikan dari kota tujuan terhadap harga tiket.
  4. Total Stops vs Price:
    * F-statistic: 2467.795974681749
      * F-statistic yang sangat tinggi menunjukkan perbedaan yang sangat signifikan antara rata-rata harga tiket pada setiap jumlah pemberhentian.
    * p-value: 0.0
      * Nilai p-value yang rendah, menunjukan perbedaan yang signifikan bukanlah suatu kebetulan.
    * ada pengaruh yang signifikan dari total pemberhentian terhadap harga tiket.

#### **Numerical features**

##### **Plot**
"""

#@markdown Plot: Melihat pengaruh fitur berjenis numerik

import seaborn as sns
sns.pairplot(data_train, diag_kind='kde')
plt.show()

#@markdown Corelation matrix: Melihat pengaruh fitur berjenis numerik

plt.figure(figsize=(10, 8))
correlation_matrix = data_train.corr().round(2)

# Untuk menge-print nilai di dalam kotak, gunakan parameter anot=True
sns.heatmap(data=correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5, )
plt.title("Correlation Matrix untuk Fitur Numerik ", size=20)

#@markdown Deskripsi Corelation matrix: Melihat pengaruh fitur berjenis numerik terhadap label "price"
print('corelation matrix')
correlation_matrix = data_train[numerical_features + ['Price']].corr()
print(correlation_matrix['Price'])

"""##### **Hasil analisa**

> Hasil analisis corelation matrix:
  1. Price vs Price:
    * korelasi antara fitur dengan dirinya sendiri. pasti 1
  2. Fitur Waktu (Hour, Minute):
    * Korelasi antara fitur waktu dengan harga tiket cukup rendah, mendekati 0.
    * menunjukkan, waktu keberangkatan tidak memiliki pengaruh yang signifikan terhadap harga tiket pesawat.  
  2. Fitur Hari dan bulan (Day, Month):
    * Korelasi antara fitur Hari dan bulan dengan harga tiket cukup mendekati angka -1.
    * menunjukkan, hari keberangkatan memiliki cukup pengaruh terhadap harga tiket pesawat.
    *  semakin besar nilai hari atau bulan keberangkatan, harga tiket cenderung lebih rendah.
  3. Duration Waktu:
    * Korelasi antara durasi penerbangan dalam menit dengan harga tiket cukup tinggi, yaitu sekitar 0.51.
    * menunjukkan, durasi penerbangan memiliki pengaruh yang signifikan terhadap harga tiket pesawat.
    * Semakin lama durasi penerbangan, kemungkinan harga tiket akan lebih tinggi.

> Sehingga dapat kita simpulkan:
  * Kolom Waktu (Dep_Hour, Dep_Min, Arrival_Hour, Arrival_Min):
    * Korelasi matriks antara fitur waktu dengan harga tiket cukup rendah, mendekati 0.
    * menunjukkan, waktu keberangkatan tidak memiliki pengaruh yang signifikan terhadap harga tiket pesawat.
    * Keputusan : KOLOM INI PERLU DI HAPUS.
"""

#@markdown Keputusan

data_train.drop(['Dep_Hour', 'Dep_Min', 'Arrival_Hour', 'Arrival_Min'], axis=1, inplace=True)

"""## <font color="#D0BFFF"><h3>Data Preparation</font>

#### **Penjelasan**

Pada tahap data preparation, dilakukan "pengemasan" atau persiapan terhadap data, agar data tersebut dapat digunakan untuk modeling. Didalam tahap tersebut terdapat proses antara lain, Encoding fitur kategori, kemudian Train-Test-Split.
Pada tahap ini tidak dilakukan Standarisasi terhadap variabel numerik, karena perbedaan skala antar tiap fitur nya sudah seragam atau tidak terlalu jauh.


1. Encoding fitur kategori
  * mengubah nilai-nilai dalam fitur kategorikal menjadi bentuk numerik
  * Dengan menerapkan OneHotEncoder dan LabelEncoder
    * OnehotEncoder
      * Dilakukan pada data Nominal, yaitu data yang tidak berurutan, atau tidak ada urutan atau hierarki yang bermakna di antara nilainya.
      * dilakukan pada kolom, Airline, Source, dan Destination.
    * LabelEncoder
      * Dilakukan pada data Ordinal, yaitu data yang berurutan, atau adanya urutan atau hierarki yang bermakna di antara nilainya.
      * dilakukan pada Time_Stops.
  * untuk,
    * mengubah data kategorikal menjadi bentuk numerik yang dapat diproses oleh algoritma machine learning.
2. Train-Test-Split,
  * Melakukan pemisahan terhadap dataset, menjadi data yang akan di training, dan data yang akan di ujikan.
  * untuk,
    * memvalidasi kinerja model machine learning sebelum menerapkannya pada data baru.
    * mengoptimalkan parameter dan hyperparameter model dengan menggunakan data validasi (test set).
  * dengan rasio data, 90:10

#### **Encoding Fitur Kategori**
"""

#@markdown Melakukan encoding

from sklearn.preprocessing import LabelEncoder

# encoding kolom Airline
Airline = data_train[["Airline"]]
Airline = pd.get_dummies(Airline, drop_first= True)

# encoding kolom Source
Source = data_train[["Source"]]
Source = pd.get_dummies(Source, drop_first= True)

# encoding kolom Destination
Destination = data_train[["Destination"]]
Destination = pd.get_dummies(Destination, drop_first = True)

# encoding kolom Total_Stops
data_train["Total_Stops"] = LabelEncoder().fit_transform(data_train["Total_Stops"])

# combine kolom tersebut
new_data_train_test = pd.concat([data_train, Airline, Source, Destination], axis = 1)
new_data_train = pd.concat([data_train, Airline, Source, Destination], axis = 1)

# hapus kolom yang tidak digunakan lagi
new_data_train.drop(["Airline", "Source", "Destination"], axis = 1, inplace = True)

new_data_train.head()

"""#### **Train-Test-Split**"""

#@markdown Memisahkan data test dan data validasi

from sklearn.model_selection import train_test_split

y = new_data_train["Price"]
X = new_data_train.drop(["Price"],axis =1)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.1, random_state = 42)

# untuk tunning model
X_trainn, X_testn, y_trainn, y_testn = train_test_split(X, y, test_size = 0.1, random_state = 42)

#@markdown Mengecek jumlah sampel pada masing-masing bagian

print(f'Total # of sample in whole dataset: {len(X)}')
print(f'Total # of sample in train dataset: {len(X_train)}')
print(f'Total # of sample in test dataset: {len(X_test)}')

"""## <font color="#D0BFFF"><h3>Modeling and Evaluation </font>

#### **Penjelasan**

* Metrik yang akan digunakan pada prediksi ini adalah MSE atau Mean Squared Error,
* Digunakan Metrik MSE karena projek ini merupakan projek Regresi.
  * dengan menghitung jumlah selisih kuadrat rata-rata nilai sebenarnya dengan nilai prediksi.
  * MSE didefinisikan dalam persamaan berikut,
    > ![image.png](data:image/png;base64,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)
      * Keterangan:
        * N = jumlah dataset
        * yi = nilai sebenarnya
        * y_pred = nilai prediksi

1. Model
  * model yang akan menjadi kandidat ada 3 model, yakni KNN, Random Forest, dan Boostting Adaboost
2. Parameter Model
  * Untuk parameter model sendiri nantinya akan didapati dari hasil tunning hyperparameter pada setiap model
  * Penjelasan Hyperparameter
    * KNN
      * n_neighbors: Menentukan jumlah tetangga yang akan dipertimbangkan oleh model untuk melakukan prediksi. model mempertimbangkan n tetangga terdekat untuk setiap prediksi.
    * RF
      * n_estimators: Menentukan jumlah pohon keputusan yang akan dibangun dalam ensemble model Random Forest. model menggunakan n pohon keputusan.
      * min_samples_split: Menentukan jumlah sampel minimum yang diperlukan untuk membagi node dalam pohon keputusan. berarti setidaknya n sampel diperlukan untuk membagi node.
      * min_samples_leaf: Menentukan jumlah sampel minimum yang diperlukan untuk menjadi daun (node terminal) dalam pohon keputusan. berarti setidaknya n sampel diperlukan untuk membentuk daun.
      * max_features: Jumlah fitur maksimum yang akan dipertimbangkan saat mencari pemisah terbaik.
        * 'auto', model menggunakan jumlah fitur yang sama dengan jumlah fitur input.
        * int Model akan mempertimbangkan sejumlah fitur tertentu, yang diatur oleh nilai integer yang ditentukan.
        * float: Model akan mempertimbangkan sebagian dari total fitur, yang diatur oleh nilai float antara 0 dan 1.
        * 'sqrt': Model akan mempertimbangkan jumlah fitur yang setara dengan akar kuadrat dari total fitur.
        * 'log2': Model akan mempertimbangkan jumlah fitur yang setara dengan logaritma basis 2 dari total fitur.
      * max_depth: Kedalaman maksimum dari setiap pohon keputusan dalam ensemble. berarti kedalaman pohon terbatas hingga n level.
    * Boositing
      * n_estimators: Menentukan jumlah model basis (misalnya, pohon keputusan lemah) yang akan digunakan dalam ensemble model Boosting. berarti terdapat n model basis.
      * learning_rate: Menentukan seberapa besar kontribusi setiap model basis terhadap keseluruhan prediksi. berarti setiap model basis memiliki dampak yang n terhadap prediksi keseluruhan.
3. Hyperparameter Tuning Process
  * untuk metode tunning hyperparameter sendiri menggunakan teknik RandomizedSearchCV
  * beberapa pertimbangan untuk memilih RandomizedSearchCV daripada GridSearch,
    * Komputasi Lebih Efisien dan cepat, Karena memilih parameter secara acak, Penyelidikan yang Lebih Luas, Dengan memilih kombinasi parameter secara acak, cenderung melakukan penyelidikan yang lebih luas pada ruang parameter.
    * kekurangan, RandomizedSearchCV tidak mencoba semua kombinasi parameter yang mungkin dari ruang parameter yang ditentukan.sehingga mungkin menghasilkan yang kurang akurat.

#### **Modeling and Tuning Process**
"""

#@markdown Proses Modeling

import pandas as pd
from sklearn.metrics import mean_squared_error, r2_score
from numpy.random import randint
from sklearn.neighbors import KNeighborsRegressor
from sklearn.ensemble import RandomForestRegressor, AdaBoostRegressor
from sklearn.model_selection import RandomizedSearchCV

allParams = {}

models = {
    'KNN': KNeighborsRegressor(),
    'RF': RandomForestRegressor(),
    'Boosting': AdaBoostRegressor()
}

# Inisialisasi dataframe untuk menyimpan hasil perbandingan
comparison_df = None
comparison_df = pd.DataFrame(columns=['Model', 'Train MSE', 'Test MSE', 'Train Score', 'Test Score',
                                      'Train MSE (Tunning)', 'Test MSE (Tunning)', 'Train Score (Tunning)', 'Test Score (Tunning)'])

# Fungsi untuk menghitung MSE dan skor sebelum dan sesudah hyperparameter tuning
def evaluate_model(model, X_trainn, y_trainn, X_testn, y_testn, param_grid):
    # Hitung MSE dan skor sebelum tuning
    model.fit(X_trainn, y_trainn)
    train_mse_before = mean_squared_error(y_trainn, model.predict(X_trainn))
    test_mse_before = mean_squared_error(y_testn, model.predict(X_testn))
    train_score_before = model.score(X_trainn, y_trainn)
    test_score_before = model.score(X_testn, y_testn)

    # Lakukan hypertuning parameter dengan RandomizedSearchCV
    search = RandomizedSearchCV(estimator=model, param_distributions=param_grid, n_iter=10, scoring='neg_mean_squared_error', cv=5, random_state=42, n_jobs=-1)
    search.fit(X_trainn, y_trainn)

    best_params = search.best_params_

    # Hitung MSE dan skor setelah tuning
    train_mse_after = mean_squared_error(y_trainn, search.best_estimator_.predict(X_trainn))
    test_mse_after = mean_squared_error(y_testn, search.best_estimator_.predict(X_testn))
    train_score_after = search.best_estimator_.score(X_trainn, y_trainn)
    test_score_after = search.best_estimator_.score(X_testn, y_testn)

    return search, best_params, train_mse_before, test_mse_before, train_score_before, test_score_before, train_mse_after, test_mse_after, train_score_after, test_score_after

# Hyperparameter grid untuk masing-masing model
param_grid = {
    'KNN': {'n_neighbors': [randint(1, 20)]},
    'RF': {'n_estimators': [randint(50, 200)], 'max_features': ['auto', 'sqrt'], 'max_depth': [randint(5, 20)], 'min_samples_split': [randint(2, 10)], 'min_samples_leaf': [randint(1, 5)]},
    'Boosting': {'n_estimators': [randint(50, 200)], 'learning_rate': [0.01, 0.05, 0.1, 0.5, 1]}
}

# Lakukan hypertuning parameter dan evaluasi model untuk setiap model
for name, model in models.items():
    search, best_params, train_mse_before, test_mse_before, train_score_before, test_score_before, train_mse_after, test_mse_after, train_score_after, test_score_after = evaluate_model(model, X_trainn, y_trainn, X_testn, y_testn, param_grid[name])

    # Tambahkan hasil evaluasi ke dataframe perbandingan

    allParams[name] = search.best_params_
    print('Best ', name, ' parameters is: ', best_params)
    comparison_df = comparison_df.append({'Model': name,
                                          'Train MSE': (train_mse_before/1e3), 'Test MSE': (test_mse_before/1e3),
                                          'Train Score': train_score_before, 'Test Score': test_score_before,
                                          'Train MSE (Tunning)': (train_mse_after/1e3), 'Test MSE (Tunning)': (test_mse_after/1e3),
                                          'Train Score (Tunning)': train_score_after, 'Test Score (Tunning)': test_score_after},
                                         ignore_index=True)

comparison_df

"""##### **Hasil analisa**

1. KNN:
  * Analisis:
    * Mean Squared Error (MSE):
      * Model KNN memiliki MSE yang cukup tinggi, baik sebelum maupun setelah penyetelan.
      * menunjukkan bahwa model cenderung tidak cocok dengan data pelatihan dan pengujian.
    * Skor:
      * Skor untuk kedua pelatihan dan pengujian juga tidak optimal, dengan peningkatan yang kecil setelah penyetelan.
      * menunjukkan bahwa model tidak dapat dengan baik memperkirakan hubungan antara fitur dan target.
    * Penyetelan:
      * Meskipun ada sedikit perbaikan dalam MSE dan skor setelah penyetelan, peningkatannya tidak signifikan.
      * menunjukkan model KNN tidak cukup fleksibel atau terlalu sederhana untuk menangani pola dalam data.
2. Random Forest (RF):
  * Analisis:
    * MSE:
      * Model Random Forest menunjukkan performa yang jauh lebih baik daripada KNN, dengan MSE yang lebih rendah baik sebelum maupun setelah penyetelan.
      * menunjukkan model ini lebih cocok dengan data dan dapat melakukan prediksi yang lebih akurat.
    * Skor:
      * Skor juga lebih tinggi untuk RF,
      * menunjukkan bahwa model lebih baik dalam memperkirakan target.
    * Penyetelan:
      * Ada peningkatan yang signifikan dalam performa model setelah penyetelan, dengan penurunan MSE dan peningkatan skor.
      * menunjukkan bahwa penyetelan parameter memperbaiki kemampuan model dalam memodelkan data.
3. Boosting:
  * Analisis:
    * MSE:
      * Model Boosting memiliki MSE yang cukup tinggi, terutama sebelum penyetelan.
      * Namun, ada peningkatan yang signifikan dalam performa setelah penyetelan, dengan penurunan yang signifikan dalam MSE.
    * Skor:
      * Skor juga meningkat setelah penyetelan,
      * menunjukkan bahwa model lebih baik dalam memperkirakan target setelah parameter yang dioptimalkan.
    * Penyetelan:
      * Penyetelan parameter telah memberikan perbaikan yang signifikan dalam performa model,
      * dengan penurunan MSE yang signifikan dan peningkatan skor.

> Kesimpulan:
  * Model Random Forest (RF) menunjukkan kinerja terbaik,
    * dengan MSE terendah dan skor tertinggi, terutama setelah penyetelan parameter.
  * Model KNN memiliki kinerja yang paling rendah,
    * dengan MSE yang tinggi dan skor yang rendah, bahkan setelah penyetelan.
  * Model Boosting menunjukkan peningkatan yang signifikan setelah penyetelan,
    * tetapi masih memiliki kinerja yang lebih rendah dibandingkan dengan RF.
  * Sehingga Model RF akan digunakan sebagai model utama dan digunakan pada tahap pengujian

### **Evaluasi matriks**
"""

#@markdown Evaluasi model

import pandas as pd
from sklearn.metrics import mean_squared_error, r2_score

# Ambil parameter terbaik untuk model Random Forest
best_params_RF = allParams['RF']

# Inisialisasi model Random Forest dengan parameter terbaik
RF = RandomForestRegressor(**best_params_RF)

# Latih model Random Forest dengan parameter terbaik
RF.fit(X_train, y_train)

# Inisialisasi dataframe untuk menyimpan hasil MSE dan skor
mse = pd.DataFrame(columns=['train', 'test', 'train_score', 'test_score'], index=['RF'])

# Hitung Mean Squared Error masing-masing algoritma pada data train dan test, serta skor performa
# Hitung MSE
mse.loc['RF', 'train'] = mean_squared_error(y_true=y_train, y_pred=RF.predict(X_train))/1e3
mse.loc['RF', 'test'] = mean_squared_error(y_true=y_test, y_pred=RF.predict(X_test))/1e3
# Hitung skor performa
mse.loc['RF', 'train_score'] = RF.score(X_train, y_train)
mse.loc['RF', 'test_score'] = RF.score(X_test, y_test)

# Tampilkan mse
mse

#@markdown Hasil scatter plot
import seaborn as sns

y_pred = RF.predict(X_test)
sns.regplot(x=y_test, y=y_pred, scatter_kws={'alpha':0.5}, line_kws={'color':'red', 'linewidth':2})
plt.xlabel("y_test")
plt.ylabel("y_pred")
plt.title(f"Scatter plot dengan Garis Hubung ")
plt.show()

"""### **Pengujian**"""

#@markdown Melakukan prediksi angka

import pandas as pd

model_dict = {'RF': RF}
# Ambil 5 baris acak dari X_test
random_rows = X_test.sample(5)

# Buat prediksi untuk setiap model
predictions = {}
predictions['Harga tiket yang di prediksi (y_true)'] = y_test.loc[random_rows.index]
for name, model in model_dict.items():
    predictions['prediksi_' + name] = model.predict(random_rows).round(1)

# Buat DataFrame dari prediksi
pd.DataFrame(predictions)

"""### **Kesimpulan**

* Fitur yang berpengaruh terhadap harga tiket pesawat adalah Durasi perjalanan. Kemudian diikuti oleh faktor Jumlah pemberhentian penerbangan, Tujuan kedatangan, Tujuan keberangkatan, dan Maskapai penerbangan.
* Tahapan dalam membangun model yang dapat memprediksi harga tiket pesawat,
  * pertama-tama membuat 3 kandidat model, yaitu Random Forest (RF), K-Nearest Neighbors (KNN), dan Boosting (AdaBoost),
  * kemudian di Lakukan tunning hyperparameter untuk mengoptimalkan kinerja model, dengan menggunakan teknik RandomizedSearchCV untuk mencari kombinasi hyperparameter terbaik.
  * setelah itu membandingkan performa dari ketiga model sebelum dan sesudah di tunning menggunakan metrik MSE.
  * model terbaik dipilih dengan nilai MSE terendah dengan skor prediksi tertinggi.
* Berdasarkan hasil analisa modeling dan tuning proses, model terbaik untuk memprediksi harga tiket pesawat adalah model Random forest.
"""